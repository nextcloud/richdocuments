<?php

declare(strict_types=1);
/**
 * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
class OC_User {
	public static function isIncognitoMode() {}
	public static function setIncognitoMode($status) {}
}

namespace OC\Files\Storage\Wrapper {
	class Wrapper implements \OCP\Files\Storage\IStorage{
		protected $storage;

		public function __construct(array $parameters) {}
		public function copy(string $source, string $target): bool {}
		public function copyFromStorage(\OCP\Files\Storage\IStorage $sourceStorage, string $sourceInternalPath, string $targetInternalPath): bool {}
		public function moveFromStorage(\OCP\Files\Storage\IStorage $sourceStorage, string $sourceInternalPath, string $targetInternalPath): bool {}
		public function rename(string $source, string $target): bool {}
		public function getId(): string {};
		public function mkdir(string $path): bool {};
		public function rmdir(string $path): bool {};
		public function opendir(string $path) {};
		public function is_dir(string $path): bool {};
		public function is_file(string $path): bool {};
		public function is_file(string $path): bool {};
        public function stat(string $path): array|false {};
        public function filetype(string $path): string|false {};
        public function filesize(string $path): int|float|false {};
        public function isCreatable(string $path): bool {};
        public function isReadable(string $path): bool {};
        public function isUpdatable(string $path): bool {};
        public function isDeletable(string $path): bool {};
        public function isSharable(string $path): bool {};
        public function getPermissions(string $path): int {};
        public function file_exists(string $path): bool {};
        public function filemtime(string $path): int|false {};
        public function file_get_contents(string $path): string|false {};
        public function file_put_contents(string $path, mixed $data): int|float|false {};
        public function unlink(string $path): bool {};
        public function rename(string $source, string $target): bool {};
        public function copy(string $source, string $target): bool {};
        public function fopen(string $path, string $mode) {};
        public function getMimeType(string $path): string|false {};
        public function hash(string $type, string $path, bool $raw = false): string|false {};
        public function free_space(string $path): int|float|false {};
        public function touch(string $path, ?int $mtime = null): bool {};
        public function getLocalFile(string $path): string|false {};
        public function hasUpdated(string $path, int $time): bool {};
        public function getCache(string $path = , ?IStorage $storage = null): ICache {};
        public function getScanner(string $path = , ?IStorage $storage = null): IScanner {};
        public function getOwner(string $path): string|false {};
        public function getWatcher(string $path = , ?IStorage $storage = null): IWatcher {};
        public function getPropagator(?IStorage $storage = null): IPropagator {};
        public function getUpdater(?IStorage $storage = null): IUpdater {};
        public function getStorageCache(): OCFilesCacheStorage {};
        public function getETag(string $path): string|false {};
        public function test(): bool {};
        public function isLocal(): bool {};
        public function instanceOfStorage(string $class): bool {};
        public function getInstanceOfStorage(string $class): ?IStorage {};
        public function __call(string $method, array $args) {};
        public function getDirectDownload(string $path): array|false {};
        public function getAvailability(): array {};
        public function setAvailability(bool $isAvailable): void {};
        public function verifyPath(string $path, string $fileName): void {};
        public function copyFromStorage(\OCP\Files\Storage\IStorage $sourceStorage, string $sourceInternalPath, string $targetInternalPath): bool {};
        public function moveFromStorage(\OCP\Files\Storage\IStorage $sourceStorage, string $sourceInternalPath, string $targetInternalPath): bool {};
        public function getMetaData(string $path): ?array {};
        public function acquireLock(string $path, int $type, ILockingProvider $provider): void {};
        public function releaseLock(string $path, int $type, ILockingProvider $provider): void {};
        public function changeLock(string $path, int $type, ILockingProvider $provider): void {};
        public function needsPartFile(): bool {};
        public function writeStream(string $path, $stream, ?int $size = null): int {};
        public function getDirectoryContent(string $directory): Traversable {};
        public function isWrapperOf(IStorage $storage): bool {};
        public function setOwner(?string $user): void {};
	}
}

namespace OC\Hooks {
	interface Emitter {
		/**
		 * @param string $scope
		 * @param string $method
		 * @param callable $callback
		 * @return void
		 * @deprecated 18.0.0 use \OCP\EventDispatcher\IEventDispatcher::addListener
		 */
		public function listen($scope, $method, callable $callback);

		/**
		 * @param string $scope optional
		 * @param string $method optional
		 * @param callable $callback optional
		 * @return void
		 * @deprecated 18.0.0 use \OCP\EventDispatcher\IEventDispatcher::removeListener
		 */
		public function removeListener($scope = null, $method = null, callable $callback = null);
	}
}

namespace OCA\DAV\Connector\Sabre {
	abstract class Node {
		public function getNode(): \OCP\Files\Node;
	}

	class FilesPlugin {
		public const SHARE_HIDE_DOWNLOAD_PROPERTYNAME = 'somePropertyName';
	}
}

namespace OCA\DAV\Events {
	class SabrePluginAddEvent extends \OCP\EventDispatcher\Event {}
}

namespace OCA\Federation {
	class TrustedServers {
		public function getServers() {
		}
		public function isTrustedServer($domainWithPort) {
		}
	}
}

namespace OCA\Viewer\Event {
	class LoadViewer extends \OCP\EventDispatcher\Event {
	}
}

namespace Doctrine\DBAL\Platforms {
	class SqlitePlatform {
	}
}

namespace OCA\Files_Sharing {
	use OCP\Files\Storage\IStorage;
	use \OCP\Share\IShare;

	abstract class SharedStorage implements IStorage {
		public function getShare(): IShare {
		}
	}
}

namespace OCA\Files_Sharing\Event {
	use \OCP\Share\IShare;

	class ShareLinkAccessedEvent extends \OCP\EventDispatcher\Event {
		public function __construct(IShare $share, string $step = '', int $errorCode = 200, string $errorMessage = '') {
		}

		public function getShare(): IShare {
		}

		public function getStep(): string {
		}

		public function getErrorCode(): int {
		}

		public function getErrorMessage(): string {
		}
	}
}

namespace OCA\Theming {
	use OCA\Theming\Service\BackgroundService;
	use OCA\Files\IAppData;
	use OCP\ICacheFactory;
	use OCP\IConfig;
	use OCP\ITempManager;
	use OCP\IURLGenerator;
	use PSR\Log\LoggerInterface;

	class ImageManager {
		public function __construct(
			IConfig $config,
			IAppData $appData,
			IURLGenerator $urlGenerator,
			ICacheFactory $cacheFactory,
			LoggerInterface $logger,
			ITempManager $tempManager,
			BackgroundService $backgroundService
		) {
		}

		public function hasImage(string $key): bool {
		}

		public function getImageUrlAbsolute(string $key): string {
		}
	}
}

class OC_Helper {
	public static function getFileTemplateManager() {
	}
}

namespace Symfony\Component\HttpFoundation {
	class IpUtils {
		public static function checkIp(?string $requestIp, $ips) {}
	}
}

#[\Attribute(Attribute::TARGET_PARAMETER)]
class SensitiveParameter {
}

class OC_Util {
	public static function setupFS(?string $user);
	public static function tearDownFS();
}

namespace OCA\Talk\Events {
	use OCP\EventDispatcher\Event;
	use OCP\Share\IShare;

	class OverwritePublicSharePropertiesEvent extends Event {
		public function __construct(
			protected IShare $share,
		) {
			parent::__construct();
		}

		public function getShare(): IShare {
			return $this->share;
		}
	}
}

namespace Sabre\DAV {
	interface INode {}

	class PropFind {
		/**
		 * @return string[]
		 */
		public function getRequestedProperties(): array {
			return [];
		}

		public function get(string $key) {
			return null;
		}

		public function set(string $key, $value) {}

		public function handle(string $key, $valueOrCallable): void {}
	}

	class Server {
		public function on(string $eventName, callable $callable): void {}
	}

    class ServerPlugin {}
}
